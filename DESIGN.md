Designing my virtual garden website took three main stages: foundations, frontend, and backend. I will take you through my process and rationale for each second in the order I coded them.

# 1. Foundation: layout, login, register
The layout serves as the primary template for the website. I designed `layout.html` with Flask’s templating (specifically the `block` structure). The navigation bar links to all pages: Garden, Inventory, Shop, Login, and Register. The login and register pages allow users to create accounts on the website. For the login page, once the inputs are validated, the app queries the SQLite database for the provided username and hashes the stored password. I store their `id` in Flask’s `session` object upon successful login. For the register page, I designed `/register` to have checks to validate user input, (all fields are filled, passwords match, chosen username is unique). Beyond this, I ensured that default entries are created for every new user in the `progress`, `inventory`, and `shop` tables.

# 2. Frontend: garden, inventory, shop, and css
I designed the homepage to be a simple retro garden concept through ASCII visuals. Through JavaScript, I used `fetch` requests using JSON triggered by planting, watering, or harvesting to synchronize user actions with the database. I also used conditional checks to ensure logical progression—preventing actions like harvesting an unplanted box—and used success and error messages to enhance clarity for users (and to help debugging). In the `Inventory` page, I added “journal entries” that include summaries of the user's collections along with buttons to transfer items to the shop. For the `Shop` page, I used a grid layout implemented with a nested table structure in Jinja to display the plants sent to the shop. I chose the `pre` tag for its monospace formatting, which aligns well with the retro ASCII art style I wanted to convey. In my CSS file, I wanted to standardize the aesthetics across all pages for simplicity. For instance, I used hover effects on buttons to give immediate visual feedback for usability. I used elements like monospace fonts, subtle textures, and specifically didn’t use Bootstrap to give the website a nostalgic charm that aligns with my inspirations for the project.

# 3. Backend: app.py and SQL databases
At the heart of the project is the Flask framework which allowed me to add python scripts to my website. The app.py file serves as the application’s backbone. It defines all key routes and ties together the frontend, backend, and database. For example, I used endpoints like `/plant-seed`, `/water-seed`, and `/harvest-seed` to define functions for each gardening action. Python allowed me to validate input (e.g., ensuring seeds must be planted before they can be watered), send and fetch info from the `index.html`, and use SQLite to store session data. For my SQLite database, I divided information into three main sections. 1: the `users` table to track users; 2: the `progress` table to log plant growth for each user; 3: `inventory` and `shop` tables to store harvested plants and available shop items (which users can transfer items to and from via `/send-to-shop`). Otherwise, I also coded pathways for each web page using `GET` and `POST` controls to both display the websites and run backend code.